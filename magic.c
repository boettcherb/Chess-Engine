#include "magic.h"
#include "defs.h"

/*
 * For each index (0-63) there is a 1-bit in the positions that make up a ray
 * headed North (towards the 8th rank) from that index.
 * Remember: bit 0 = A1, bit 1 = B1, ... , bit 62 = G8, bit 63 = H8.
 * 
 *                      0 0 0 0 0 1 0 0
 *                      0 0 0 0 0 1 0 0
 *                      0 0 0 0 0 1 0 0
 * Ex: rayNorth[F2]  =  0 0 0 0 0 1 0 0
 *                      0 0 0 0 0 1 0 0
 *                      0 0 0 0 0 1 0 0
 *                      0 0 0 0 0 0 0 0
 *                      0 0 0 0 0 0 0 0
 */
const uint64 rayNorth[64] = {
    0x0101010101010100, 0x0202020202020200, 0x0404040404040400, 0x0808080808080800,
    0x1010101010101000, 0x2020202020202000, 0x4040404040404000, 0x8080808080808000,
    0x0101010101010000, 0x0202020202020000, 0x0404040404040000, 0x0808080808080000,
    0x1010101010100000, 0x2020202020200000, 0x4040404040400000, 0x8080808080800000,
    0x0101010101000000, 0x0202020202000000, 0x0404040404000000, 0x0808080808000000,
    0x1010101010000000, 0x2020202020000000, 0x4040404040000000, 0x8080808080000000,
    0x0101010100000000, 0x0202020200000000, 0x0404040400000000, 0x0808080800000000,
    0x1010101000000000, 0x2020202000000000, 0x4040404000000000, 0x8080808000000000,
    0x0101010000000000, 0x0202020000000000, 0x0404040000000000, 0x0808080000000000,
    0x1010100000000000, 0x2020200000000000, 0x4040400000000000, 0x8080800000000000,
    0x0101000000000000, 0x0202000000000000, 0x0404000000000000, 0x0808000000000000,
    0x1010000000000000, 0x2020000000000000, 0x4040000000000000, 0x8080000000000000,
    0x0100000000000000, 0x0200000000000000, 0x0400000000000000, 0x0800000000000000,
    0x1000000000000000, 0x2000000000000000, 0x4000000000000000, 0x8000000000000000,
    0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000,
    0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000,
};

/*
 * For each index (0-63) there is a 1-bit in the positions that make up a ray
 * headed South (towards the 1st rank) from that index.
 * Remember: bit 0 = A1, bit 1 = B1, ... , bit 62 = G8, bit 63 = H8.
 * 
 *                      0 0 0 0 0 0 0 0
 *                      0 0 0 0 0 1 0 0
 *                      0 0 0 0 0 1 0 0
 * Ex: raySouth[F8]  =  0 0 0 0 0 1 0 0
 *                      0 0 0 0 0 1 0 0
 *                      0 0 0 0 0 1 0 0
 *                      0 0 0 0 0 1 0 0
 *                      0 0 0 0 0 1 0 0
 */
const uint64 raySouth[64] = {
    0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000,
    0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000,
    0x0000000000000001, 0x0000000000000002, 0x0000000000000004, 0x0000000000000008,
    0x0000000000000010, 0x0000000000000020, 0x0000000000000040, 0x0000000000000080,
    0x0000000000000101, 0x0000000000000202, 0x0000000000000404, 0x0000000000000808,
    0x0000000000001010, 0x0000000000002020, 0x0000000000004040, 0x0000000000008080,
    0x0000000000010101, 0x0000000000020202, 0x0000000000040404, 0x0000000000080808,
    0x0000000000101010, 0x0000000000202020, 0x0000000000404040, 0x0000000000808080,
    0x0000000001010101, 0x0000000002020202, 0x0000000004040404, 0x0000000008080808,
    0x0000000010101010, 0x0000000020202020, 0x0000000040404040, 0x0000000080808080,
    0x0000000101010101, 0x0000000202020202, 0x0000000404040404, 0x0000000808080808,
    0x0000001010101010, 0x0000002020202020, 0x0000004040404040, 0x0000008080808080,
    0x0000010101010101, 0x0000020202020202, 0x0000040404040404, 0x0000080808080808,
    0x0000101010101010, 0x0000202020202020, 0x0000404040404040, 0x0000808080808080,
    0x0001010101010101, 0x0002020202020202, 0x0004040404040404, 0x0008080808080808,
    0x0010101010101010, 0x0020202020202020, 0x0040404040404040, 0x0080808080808080,
};

/*
 * For each index (0-63) there is a 1-bit in the positions that make up a ray
 * headed East (towards the A file) from that index.
 * Remember: bit 0 = A1, bit 1 = B1, ... , bit 62 = G8, bit 63 = H8.
 * 
 *                     0 0 0 0 0 0 0 0
 *                     0 0 0 0 0 0 0 0
 *                     0 0 0 0 0 0 0 0
 * Ex: rayEast[D5]  =  1 1 1 0 0 0 0 0
 *                     0 0 0 0 0 0 0 0
 *                     0 0 0 0 0 0 0 0
 *                     0 0 0 0 0 0 0 0
 *                     0 0 0 0 0 0 0 0
 */
const uint64 rayEast[64] = {
    0x00000000000000FE, 0x00000000000000FC, 0x00000000000000F8, 0x00000000000000F0,
    0x00000000000000E0, 0x00000000000000C0, 0x0000000000000080, 0x0000000000000000,
    0x000000000000FE00, 0x000000000000FC00, 0x000000000000F800, 0x000000000000F000,
    0x000000000000E000, 0x000000000000C000, 0x0000000000008000, 0x0000000000000000,
    0x0000000000FE0000, 0x0000000000FC0000, 0x0000000000F80000, 0x0000000000F00000,
    0x0000000000E00000, 0x0000000000C00000, 0x0000000000800000, 0x0000000000000000,
    0x00000000FE000000, 0x00000000FC000000, 0x00000000F8000000, 0x00000000F0000000,
    0x00000000E0000000, 0x00000000C0000000, 0x0000000080000000, 0x0000000000000000,
    0x000000FE00000000, 0x000000FC00000000, 0x000000F800000000, 0x000000F000000000,
    0x000000E000000000, 0x000000C000000000, 0x0000008000000000, 0x0000000000000000,
    0x0000FE0000000000, 0x0000FC0000000000, 0x0000F80000000000, 0x0000F00000000000,
    0x0000E00000000000, 0x0000C00000000000, 0x0000800000000000, 0x0000000000000000,
    0x00FE000000000000, 0x00FC000000000000, 0x00F8000000000000, 0x00F0000000000000,
    0x00E0000000000000, 0x00C0000000000000, 0x0080000000000000, 0x0000000000000000,
    0xFE00000000000000, 0xFC00000000000000, 0xF800000000000000, 0xF000000000000000,
    0xE000000000000000, 0xC000000000000000, 0x8000000000000000, 0x0000000000000000,
};

/*
 * For each index (0-63) there is a 1-bit in the positions that make up a ray
 * headed East (towards the H file) from that index.
 * Remember: bit 0 = A1, bit 1 = B1, ... , bit 62 = G8, bit 63 = H8.
 * 
 *                     0 0 0 0 0 0 0 0
 *                     0 0 0 0 0 0 0 0
 *                     0 0 0 0 0 0 0 0
 * Ex: rayWest[D5]  =  0 0 0 0 1 1 1 1
 *                     0 0 0 0 0 0 0 0
 *                     0 0 0 0 0 0 0 0
 *                     0 0 0 0 0 0 0 0
 *                     0 0 0 0 0 0 0 0
 */
const uint64 rayWest[64] = {
    0x0000000000000000, 0x0000000000000001, 0x0000000000000003, 0x0000000000000007,
    0x000000000000000F, 0x000000000000001F, 0x000000000000003F, 0x000000000000007F,
    0x0000000000000000, 0x0000000000000100, 0x0000000000000300, 0x0000000000000700,
    0x0000000000000F00, 0x0000000000001F00, 0x0000000000003F00, 0x0000000000007F00,
    0x0000000000000000, 0x0000000000010000, 0x0000000000030000, 0x0000000000070000,
    0x00000000000F0000, 0x00000000001F0000, 0x00000000003F0000, 0x00000000007F0000,
    0x0000000000000000, 0x0000000001000000, 0x0000000003000000, 0x0000000007000000,
    0x000000000F000000, 0x000000001F000000, 0x000000003F000000, 0x000000007F000000,
    0x0000000000000000, 0x0000000100000000, 0x0000000300000000, 0x0000000700000000,
    0x0000000F00000000, 0x0000001F00000000, 0x0000003F00000000, 0x0000007F00000000,
    0x0000000000000000, 0x0000010000000000, 0x0000030000000000, 0x0000070000000000,
    0x00000F0000000000, 0x00001F0000000000, 0x00003F0000000000, 0x00007F0000000000,
    0x0000000000000000, 0x0001000000000000, 0x0003000000000000, 0x0007000000000000,
    0x000F000000000000, 0x001F000000000000, 0x003F000000000000, 0x007F000000000000,
    0x0000000000000000, 0x0100000000000000, 0x0300000000000000, 0x0700000000000000,
    0x0F00000000000000, 0x1F00000000000000, 0x3F00000000000000, 0x7F00000000000000,
};

/*
 * For each index (0-63) there is a 1-bit in the positions that make up a ray
 * headed NorthWest (towards the 8th rank and the A file) from that index.
 * Remember: bit 0 = A1, bit 1 = B1, ... , bit 62 = G8, bit 63 = H8.
 * 
 *                          0 1 0 0 0 0 0 0
 *                          0 0 1 0 0 0 0 0
 *                          0 0 0 1 0 0 0 0
 * Ex: rayNorthWest[G3]  =  0 0 0 0 1 0 0 0
 *                          0 0 0 0 0 1 0 0
 *                          0 0 0 0 0 0 0 0
 *                          0 0 0 0 0 0 0 0
 *                          0 0 0 0 0 0 0 0
 */
const uint64 rayNorthWest[64] = {
    0x0000000000000000, 0x0000000000000100, 0x0000000000010200, 0x0000000001020400,
    0x0000000102040800, 0x0000010204081000, 0x0001020408102000, 0x0102040810204000,
    0x0000000000000000, 0x0000000000010000, 0x0000000001020000, 0x0000000102040000,
    0x0000010204080000, 0x0001020408100000, 0x0102040810200000, 0x0204081020400000,
    0x0000000000000000, 0x0000000001000000, 0x0000000102000000, 0x0000010204000000,
    0x0001020408000000, 0x0102040810000000, 0x0204081020000000, 0x0408102040000000,
    0x0000000000000000, 0x0000000100000000, 0x0000010200000000, 0x0001020400000000,
    0x0102040800000000, 0x0204081000000000, 0x0408102000000000, 0x0810204000000000,
    0x0000000000000000, 0x0000010000000000, 0x0001020000000000, 0x0102040000000000,
    0x0204080000000000, 0x0408100000000000, 0x0810200000000000, 0x1020400000000000,
    0x0000000000000000, 0x0001000000000000, 0x0102000000000000, 0x0204000000000000,
    0x0408000000000000, 0x0810000000000000, 0x1020000000000000, 0x2040000000000000,
    0x0000000000000000, 0x0100000000000000, 0x0200000000000000, 0x0400000000000000,
    0x0800000000000000, 0x1000000000000000, 0x2000000000000000, 0x4000000000000000,
    0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000,
    0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000,
};

/*
 * For each index (0-63) there is a 1-bit in the positions that make up a ray
 * headed NorthEast (towards the 8th rank and the H file) from that index.
 * Remember: bit 0 = A1, bit 1 = B1, ... , bit 62 = G8, bit 63 = H8.
 * 
 *                          0 0 0 0 0 0 0 1
 *                          0 0 0 0 0 0 1 0
 *                          0 0 0 0 0 1 0 0
 * Ex: rayNorthEast[A1]  =  0 0 0 0 1 0 0 0
 *                          0 0 0 1 0 0 0 0
 *                          0 0 1 0 0 0 0 0
 *                          0 1 0 0 0 0 0 0
 *                          0 0 0 0 0 0 0 0
 */
const uint64 rayNorthEast[64] = {
    0x8040201008040200, 0x0080402010080400, 0x0000804020100800, 0x0000008040201000,
    0x0000000080402000, 0x0000000000804000, 0x0000000000008000, 0x0000000000000000,
    0x4020100804020000, 0x8040201008040000, 0x0080402010080000, 0x0000804020100000,
    0x0000008040200000, 0x0000000080400000, 0x0000000000800000, 0x0000000000000000,
    0x2010080402000000, 0x4020100804000000, 0x8040201008000000, 0x0080402010000000,
    0x0000804020000000, 0x0000008040000000, 0x0000000080000000, 0x0000000000000000,
    0x1008040200000000, 0x2010080400000000, 0x4020100800000000, 0x8040201000000000,
    0x0080402000000000, 0x0000804000000000, 0x0000008000000000, 0x0000000000000000,
    0x0804020000000000, 0x1008040000000000, 0x2010080000000000, 0x4020100000000000,
    0x8040200000000000, 0x0080400000000000, 0x0000800000000000, 0x0000000000000000,
    0x0402000000000000, 0x0804000000000000, 0x1008000000000000, 0x2010000000000000,
    0x4020000000000000, 0x8040000000000000, 0x0080000000000000, 0x0000000000000000,
    0x0200000000000000, 0x0400000000000000, 0x0800000000000000, 0x1000000000000000,
    0x2000000000000000, 0x4000000000000000, 0x8000000000000000, 0x0000000000000000,
    0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000,
    0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000,
};

/*
 * For each index (0-63) there is a 1-bit in the positions that make up a ray
 * headed SouthWest (towards the 1st rank and the A file) from that index.
 * Remember: bit 0 = A1, bit 1 = B1, ... , bit 62 = G8, bit 63 = H8.
 * 
 *                          0 0 0 0 0 0 0 0
 *                          0 0 0 0 0 0 0 0
 *                          0 0 0 0 0 1 0 0
 * Ex: raySouthWest[G7]  =  0 0 0 0 1 0 0 0
 *                          0 0 0 1 0 0 0 0
 *                          0 0 1 0 0 0 0 0
 *                          0 1 0 0 0 0 0 0
 *                          1 0 0 0 0 0 0 0
 */
const uint64 raySouthWest[64] = {
    0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000,
    0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000,
    0x0000000000000000, 0x0000000000000001, 0x0000000000000002, 0x0000000000000004,
    0x0000000000000008, 0x0000000000000010, 0x0000000000000020, 0x0000000000000040,
    0x0000000000000000, 0x0000000000000100, 0x0000000000000201, 0x0000000000000402,
    0x0000000000000804, 0x0000000000001008, 0x0000000000002010, 0x0000000000004020,
    0x0000000000000000, 0x0000000000010000, 0x0000000000020100, 0x0000000000040201,
    0x0000000000080402, 0x0000000000100804, 0x0000000000201008, 0x0000000000402010,
    0x0000000000000000, 0x0000000001000000, 0x0000000002010000, 0x0000000004020100,
    0x0000000008040201, 0x0000000010080402, 0x0000000020100804, 0x0000000040201008,
    0x0000000000000000, 0x0000000100000000, 0x0000000201000000, 0x0000000402010000,
    0x0000000804020100, 0x0000001008040201, 0x0000002010080402, 0x0000004020100804,
    0x0000000000000000, 0x0000010000000000, 0x0000020100000000, 0x0000040201000000,
    0x0000080402010000, 0x0000100804020100, 0x0000201008040201, 0x0000402010080402,
    0x0000000000000000, 0x0001000000000000, 0x0002010000000000, 0x0004020100000000,
    0x0008040201000000, 0x0010080402010000, 0x0020100804020100, 0x0040201008040201,
};

/*
 * For each index (0-63) there is a 1-bit in the positions that make up a ray
 * headed SouthEast (towards the 1st rank and the H file) from that index.
 * Remember: bit 0 = A1, bit 1 = B1, ... , bit 62 = G8, bit 63 = H8.
 * 
 *                          0 0 0 0 0 0 0 0
 *                          0 0 1 0 0 0 0 0
 *                          0 0 0 1 0 0 0 0
 * Ex: raySouthEast[B8]  =  0 0 0 0 1 0 0 0
 *                          0 0 0 0 0 1 0 0
 *                          0 0 0 0 0 0 1 0
 *                          0 0 0 0 0 0 0 1
 *                          0 0 0 0 0 0 0 0
 */
const uint64 raySouthEast[64] = {
    0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000,
    0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000,
    0x0000000000000002, 0x0000000000000004, 0x0000000000000008, 0x0000000000000010,
    0x0000000000000020, 0x0000000000000040, 0x0000000000000080, 0x0000000000000000,
    0x0000000000000204, 0x0000000000000408, 0x0000000000000810, 0x0000000000001020,
    0x0000000000002040, 0x0000000000004080, 0x0000000000008000, 0x0000000000000000,
    0x0000000000020408, 0x0000000000040810, 0x0000000000081020, 0x0000000000102040,
    0x0000000000204080, 0x0000000000408000, 0x0000000000800000, 0x0000000000000000,
    0x0000000002040810, 0x0000000004081020, 0x0000000008102040, 0x0000000010204080,
    0x0000000020408000, 0x0000000040800000, 0x0000000080000000, 0x0000000000000000,
    0x0000000204081020, 0x0000000408102040, 0x0000000810204080, 0x0000001020408000,
    0x0000002040800000, 0x0000004080000000, 0x0000008000000000, 0x0000000000000000,
    0x0000020408102040, 0x0000040810204080, 0x0000081020408000, 0x0000102040800000,
    0x0000204080000000, 0x0000408000000000, 0x0000800000000000, 0x0000000000000000,
    0x0002040810204080, 0x0004081020408000, 0x0008102040800000, 0x0010204080000000,
    0x0020408000000000, 0x0040800000000000, 0x0080000000000000, 0x0000000000000000,
};

/*
 * For each index (0-63) there is a 1-bit in the positions that a bishop (for
 * bishopAttacks[]) or a rook (for rookAttacks[]) at that index would be able
 * to attack. These arrays are only used with the functions rookAttacksSlow(),
 * bishopAttacksSlow(), initRookAttackTable(), and initBishopAttackTable()
 * during the initialization of the chess engine.
 * Remember: bit 0 = A1, bit 1 = B1, ... , bit 62 = G8, bit 63 = H8.
 * 
 *    Ex: bishopAttacks[D4] =     |       Ex: rookAttacks[D4] = 
 *        0 0 0 0 0 0 0 1         |         0 0 0 1 0 0 0 0
 *        1 0 0 0 0 0 1 0         |         0 0 0 1 0 0 0 0
 *        0 1 0 0 0 1 0 0         |         0 0 0 1 0 0 0 0
 *        0 0 1 0 1 0 0 0         |         0 0 0 1 0 0 0 0
 *        0 0 0 0 0 0 0 0         |         1 1 1 0 1 1 1 1
 *        0 0 1 0 1 0 0 0         |         0 0 0 1 0 0 0 0
 *        0 1 0 0 0 1 0 0         |         0 0 0 1 0 0 0 0
 *        1 0 0 0 0 0 1 0         |         0 0 0 1 0 0 0 0
 */
const uint64 bishopAttacks[64] = {
    0x8040201008040200, 0x0080402010080500, 0x0000804020110A00, 0x0000008041221400,
    0x0000000182442800, 0x0000010204885000, 0x000102040810A000, 0x0102040810204000,
    0x4020100804020002, 0x8040201008050005, 0x00804020110A000A, 0x0000804122140014,
    0x0000018244280028, 0x0001020488500050, 0x0102040810A000A0, 0x0204081020400040,
    0x2010080402000204, 0x4020100805000508, 0x804020110A000A11, 0x0080412214001422,
    0x0001824428002844, 0x0102048850005088, 0x02040810A000A010, 0x0408102040004020,
    0x1008040200020408, 0x2010080500050810, 0x4020110A000A1120, 0x8041221400142241,
    0x0182442800284482, 0x0204885000508804, 0x040810A000A01008, 0x0810204000402010,
    0x0804020002040810, 0x1008050005081020, 0x20110A000A112040, 0x4122140014224180,
    0x8244280028448201, 0x0488500050880402, 0x0810A000A0100804, 0x1020400040201008,
    0x0402000204081020, 0x0805000508102040, 0x110A000A11204080, 0x2214001422418000,
    0x4428002844820100, 0x8850005088040201, 0x10A000A010080402, 0x2040004020100804,
    0x0200020408102040, 0x0500050810204080, 0x0A000A1120408000, 0x1400142241800000,
    0x2800284482010000, 0x5000508804020100, 0xA000A01008040201, 0x4000402010080402,
    0x0002040810204080, 0x0005081020408000, 0x000A112040800000, 0x0014224180000000,
    0x0028448201000000, 0x0050880402010000, 0x00A0100804020100, 0x0040201008040201,
};
const uint64 rookAttacks[64] = {
    0x01010101010101FE, 0x02020202020202FD, 0x04040404040404FB, 0x08080808080808F7,
    0x10101010101010EF, 0x20202020202020DF, 0x40404040404040BF, 0x808080808080807F,
    0x010101010101FE01, 0x020202020202FD02, 0x040404040404FB04, 0x080808080808F708,
    0x101010101010EF10, 0x202020202020DF20, 0x404040404040BF40, 0x8080808080807F80,
    0x0101010101FE0101, 0x0202020202FD0202, 0x0404040404FB0404, 0x0808080808F70808,
    0x1010101010EF1010, 0x2020202020DF2020, 0x4040404040BF4040, 0x80808080807F8080,
    0x01010101FE010101, 0x02020202FD020202, 0x04040404FB040404, 0x08080808F7080808,
    0x10101010EF101010, 0x20202020DF202020, 0x40404040BF404040, 0x808080807F808080,
    0x010101FE01010101, 0x020202FD02020202, 0x040404FB04040404, 0x080808F708080808,
    0x101010EF10101010, 0x202020DF20202020, 0x404040BF40404040, 0x8080807F80808080,
    0x0101FE0101010101, 0x0202FD0202020202, 0x0404FB0404040404, 0x0808F70808080808,
    0x1010EF1010101010, 0x2020DF2020202020, 0x4040BF4040404040, 0x80807F8080808080,
    0x01FE010101010101, 0x02FD020202020202, 0x04FB040404040404, 0x08F7080808080808,
    0x10EF101010101010, 0x20DF202020202020, 0x40BF404040404040, 0x807F808080808080,
    0xFE01010101010101, 0xFD02020202020202, 0xFB04040404040404, 0xF708080808080808,
    0xEF10101010101010, 0xDF20202020202020, 0xBF40404040404040, 0x7F80808080808080,
};

/*
 * Given the square index of a sliding-piece (a bishop or queen when using
 * bishopAttacksSlow() and a rook or queen when using rookAttacksSlow()) and a
 * bitboard of every piece on the chessboard, return a bitboard containing the
 * attacks of that sliding piece.
 * Generating an attack bitboard for sliding pieces (rook, bishop, queen) is
 * more difficult than for non-sliding pieces (king, knight, pawn) because we
 * must take into account the positions of every other piece on the board.
 * Pieces that limit the movement of sliding pieces are called "blockers" and
 * can be found using the ray bitboards (ex: bitboard & rayNorth[sq] gives the
 * blockers to the north of a rook on the square 'sq'). Since there can be
 * multiple blockers in a single direction, use the getLSB() and getMSB()
 * functions (defined in defs.c) to find the blocker that is closest to the
 * sliding piece. Use this blocker and the ray bitboards to limit the attacks
 * of the sliding piece and to generate the correct attack bitboard.
 * These functions (bishopAttacksSlow() and rookAttacksSlow()) and the ray
 * bitboards are only used during the intialization of the chess engine to
 * fill the sliding piece attack tables. The functions getBishopAttacks(), 
 * getRookAttacks(), and getQueenAttacks() from attack.c will be used during
 * run-time to quickly query attack bitboards from the attack tables.
 * 
 * square:      An integer denoting the position of a sliding piece (a bishop
 *              for bishopAttacksSlow() and a rook for rookAttacksSlow()). 
 *              Must be in the range [0 - 63].
 * allPiece:    A bitboard with a 1 bit in every position that contains a
 *              piece.
 * 
 * return:      A bitboard with a 1 bit in every position that the sliding
 *              piece on the square 'square' can attack.
 */
uint64 bishopAttacksSlow(int square, uint64 allPieces) {
    assert(square >= 0 && square < 64);
    uint64 bishopMoves = bishopAttacks[square];
    uint64 blockersNorthEast = rayNorthEast[square] & allPieces;
    uint64 blockersNorthWest = rayNorthWest[square] & allPieces;
    uint64 blockersSouthEast = raySouthEast[square] & allPieces;
    uint64 blockersSouthWest = raySouthWest[square] & allPieces;
    if (blockersNorthEast) {
        bishopMoves &= ~rayNorthEast[getLSB(blockersNorthEast)];
    }
    if (blockersNorthWest) {
        bishopMoves &= ~rayNorthWest[getLSB(blockersNorthWest)];
    }
    if (blockersSouthEast) {
        bishopMoves &= ~raySouthEast[getMSB(blockersSouthEast)];
    }
    if (blockersSouthWest) {
        bishopMoves &= ~raySouthWest[getMSB(blockersSouthWest)];
    }
    return bishopMoves;
}
uint64 rookAttacksSlow(int square, uint64 allPieces) {
    assert(square >= 0 && square < 64);
    uint64 rookMoves = rookAttacks[square];
    uint64 blockersNorth = rayNorth[square] & allPieces;
    uint64 blockersSouth = raySouth[square] & allPieces;
    uint64 blockersEast = rayEast[square] & allPieces;
    uint64 blockersWest = rayWest[square] & allPieces;
    if (blockersNorth) {
        rookMoves &= ~rayNorth[getLSB(blockersNorth)];
    }
    if (blockersSouth) {
        rookMoves &= ~raySouth[getMSB(blockersSouth)];
    }
    if (blockersEast) {
        rookMoves &= ~rayEast[getLSB(blockersEast)];
    }
    if (blockersWest) {
        rookMoves &= ~rayWest[getMSB(blockersWest)];
    }
    return rookMoves;
}
